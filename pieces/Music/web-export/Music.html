<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, minimumscale=1.0, maximum-scale=1.0" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="stylesheet" type="text/css" href="../../styles/styles.css" />
		<!-- Uncomment when logo is complete and converted to an ico file -->
		<!-- <link rel="shortcut icon" type="iamge/x-icon" href="media/favicon.ico" -->
		<title>Ryan Bell</title>	
	</head>
	<body>
		<nav>
			<div id="navName">
				<a href="../../home.html">RYAN BELL</a>
			</div>
			<div class="navList">
				<ul>
					<li><a class="navLink" href="portfolio.html">Portfolio</a></li>
					<li><a class="navLink" href="about.html">About</a></li>
					<li><a class="navLink" href="resume.html">Resume</a></li>
					<li><a class="navLink" href="content.html">Contact</a></li> 
				</ul>
			</div>
		</nav>
		
		<section id="introduction">
			<h1>Something about the projects?</h1>
			<p>This may not be neccessary</p>
		</section>
		<script src="processing.js" type="text/javascript"></script>
		<script type="text/javascript">
			if ( window.addEventListener ) {
			window.addEventListener("load", function() {
				var scripts = document.getElementsByTagName("script");
			
				for ( var i = 0; i < scripts.length; i++ ) {
				if ( scripts[i].type == "application/processing" ) {
					var src = scripts[i].getAttribute("target");
					var canvas = scripts[i].nextSibling;
			
					if ( src && src.indexOf("#") > -1 ) {
					canvas = document.getElementById( src.substr( src.indexOf("#") + 1 ) );
					} else {
					while ( canvas && canvas.nodeName.toUpperCase() != "CANVAS" )
					canvas = canvas.nextSibling;
					}
			
					if ( canvas ) {
					Processing(canvas, scripts[i].text);
					}
				}
				}
			}, false);
			}
		</script>
		<script type="text/javascript">
		
					
			function Minim() {
			this.loadFile = function (str) {
				return new AudioPlayer(str);
			}
			}
			
			// Browser Audio API
			function AudioPlayer(str) {
			var loaded = false;
			var looping = false;
			
			if (!!document.createElement('audio').canPlayType) {
				var audio = document.createElement('audio');
				audio.addEventListener('ended', function () {
				if (looping) {
					this.currentTime = 0;
					this.play();
				}
				}, false);
				audio.preload = 'auto';
				audio.autobuffer = true;
				if (canPlayOgg()) {
				audio.src = str.split(".")[0] + ".ogg";
				} else if (canPlayMp3()) {
				audio.src = str;
				}
				loaded = true;
			}
			this.play = function () {
				if (!loaded) {
				var local = this;
				setTimeout(function() { local.play(); }, 50);
				return;
				}
				audio.play();
			};
			this.loop = function () {
				if (!loaded) {
				var local = this;
				setTimeout(function() { local.loop(); }, 50);
				return;
				}
				//audio.loop = 'loop';
				looping = true;
				audio.play();
			};
			this.pause = function () {
				if (!loaded) {
				return;
				}
				audio.pause();
			};
			this.rewind = function () {
				if (!loaded) {
				return;
				}
				// rewind the sound to start
				if(audio.currentTime) {
				audio.currentTime = 0;
				}
			};
			this.position = function() {
				if (!loaded) {
				return -1;
				}
				if(audio.currentTime) {
				return audio.currentTime * 1000;
				}
				return -1;
			};
			this.cue = function(position) {
				if (!loaded) {
				return;
				}
				if(audio.currentTime) {
				audio.currentTime = position / 1000;
				}
			};
			this.mute = function() {
				audio.volume = 0.0;
			};
			this.unmute = function() {
				audio.volume = 1.0;
			};
			}
			
			function canPlayOgg() {
			var a = document.createElement('audio');
			return !!(a.canPlayType && a.canPlayType('audio/ogg; codecs="vorbis"').replace(/no/, ''));
			}
			
			function canPlayMp3() {
			var a = document.createElement('audio');
			return !!(a.canPlayType && a.canPlayType('audio/mpeg;').replace(/no/, ''));
			}
					
					
			</script>
			<script type="text/javascript">
			
			
			(function(){ 
  
				Processing.lib.PJSAudio = function() {
					// Contants
					PJSAudio = {
					SINEWAVE:     1,
					SQUAREWAVE:   2,
					SAWWAVE:      3,
					TRIANGLEWAVE: 4,
					LOWPASS:      5,
					HIGHPASS:     6
					};
				
					this.DFT = function(_bufferSize, _sampleRate) {
					var bufferSize = _bufferSize;
					var sampleRate = _sampleRate;
					
					var self = {
						spectrum: new Array(bufferSize/2),
						complexValues: new Array(bufferSize/2),
						
						buildTrigTables: function() {
						var N = bufferSize/2 * bufferSize;
						var TWO_PI = 2 * Math.PI;
						
						self.sinTable = new Array(N);
						self.cosTable = new Array(N);
						
						for ( var i = 0; i < N; i++ ) {
							self.sinTable[i] = Math.sin(i * TWO_PI / bufferSize);
							self.cosTable[i] = Math.cos(i * TWO_PI / bufferSize);
						}
						},
						
						forward: function(buffer) {
						for ( var k = 0; k < bufferSize/2; k ++ ) {
							var real = 0.0;
							var imag = 0.0;
				
							for ( var n = 0; n < buffer.length; n++ ) {
							real += self.cosTable[k*n] * signal[n];
							imag += self.sinTable[k*n] * signal[n];
							}
				
							self.complexValues[k] = {real: real, imag: imag};
						}
						
						for ( var i = 0; i < bufferSize/2; i++ ) {
							self.spectrum[i] = 2 * Math.sqrt(Math.pow(self.complexValues[i].real, 2) + Math.pow(self.complexValues[i].imag, 2)) / bufferSize;
						}
				
						return self.spectrum;
						}
					};
					
					self.buildTrigTables();
					
					return self;
					}; // END DFT
					
					this.FFT = function(_bufferSize, _sampleRate) {
					var bufferSize = _bufferSize;
					var sampleRate = _sampleRate;
				
					var self = {
						spectrum: new Array(bufferSize/2),
						complexValues: new Array(bufferSize),
						
						buildReverseTable: function() {
						self.reverseTable = new Array(bufferSize);
						self.reverseTable[0] = 0;
				
						var limit = 1;
						var bit = bufferSize >> 1;
				
						while ( limit < bufferSize ) {
							for ( var i = 0; i < limit; i++ ) {
							self.reverseTable[i + limit] = self.reverseTable[i] + bit;
							}
				
							limit = limit << 1;
							bit = bit >> 1;
						}
						},
						
						buildTrigTables: function() {
						self.sinTable = new Array(bufferSize);
						self.cosTable = new Array(bufferSize);
						
						for ( var i = 0; i < bufferSize; i++ ) {
							self.sinTable[i] = Math.sin(-Math.PI/i);
							self.cosTable[i] = Math.cos(-Math.PI/i);
						}
						},
						
						forward: function(buffer) {
						if ( bufferSize % 2 != 0 ) throw "Invalid buffer size, must be a power of 2.";
						if ( bufferSize != buffer.length ) throw "Supplied buffer is not the same size as defined FFT. FFT Size: " + bufferSize + " Buffer Size: " + buffer.length;
				
						for ( var i = 0; i < buffer.length; i++ ) {
							self.complexValues[i] = {real: buffer[self.reverseTable[i]], imag: 0.0};
						}
				
						var halfSize = 1;
				
						while ( halfSize < buffer.length ) {
							var phaseShiftStepReal = self.cosTable[halfSize];
							var phaseShiftStepImag = self.sinTable[halfSize];
							var currentPhaseShiftReal = 1.0;
							var currentPhaseShiftImag = 0.0;
				
							for ( var fftStep = 0; fftStep < halfSize; fftStep++ ) {
							var i = fftStep;
				
							while ( i < buffer.length ) {
								var off = i + halfSize;
								var tr = (currentPhaseShiftReal * self.complexValues[off].real) - (currentPhaseShiftImag * self.complexValues[off].imag);
								var ti = (currentPhaseShiftReal * self.complexValues[off].imag) + (currentPhaseShiftImag * self.complexValues[off].real);
				
								self.complexValues[off].real = self.complexValues[i].real - tr;
								self.complexValues[off].imag = self.complexValues[i].imag - ti;
								self.complexValues[i].real += tr;
								self.complexValues[i].imag += ti;
				
								i += halfSize << 1;
							}
				
							var tmpReal = currentPhaseShiftReal;
							currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
							currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
							}
				
							halfSize = halfSize << 1;
						}
				
						for ( var i = 0; i < bufferSize/2; i++ ) {
							self.spectrum[i] = 2 * Math.sqrt(Math.pow(self.complexValues[i].real, 2) + Math.pow(self.complexValues[i].imag, 2)) / bufferSize;
						}
						
						return self.spectrum;
						}
					}
					
					self.buildReverseTable();
					self.buildTrigTables();
				
					return self;
					}; // END FFT
					
					/*  Oscillator Signal Generator
					*    
					*  Usage: var sine = Oscillator(SINEWAVE, 440.0, 1, 2048, 44100);
					*         var signal = sine.generate();
					*
					*/
				
					this.Oscillator = function(_waveform, _frequency, _amplitude, _bufferSize, _sampleRate) {
					var waveform = _waveform;
					var frequency = _frequency;
					var amplitude = _amplitude;
					var bufferSize = _bufferSize;
					var sampleRate = _sampleRate;
					var waveLength;
					var frameCount = 0;
					
					var cyclesPerSample = frequency / sampleRate;
					
					var TWO_PI = 2*Math.PI;
					
					var calcWaveLength = function() {
						var waveLengthSize = Math.round(sampleRate / frequency);
						waveLength = new Array(waveLengthSize);
						
						for ( var i = 0; i < waveLengthSize; i++ ) {
						var value;
						var step = i * cyclesPerSample % 1;
				
						switch(waveform) {
							case PJSAudio.SINEWAVE:
							value = Math.sin(TWO_PI * step);
							break;
							case PJSAudio.SQUAREWAVE:
							value = step < 0.5 ? 1 : -1;
							break;
							case PJSAudio.SAWWAVE:
							value = 2 * (step - Math.round(step));
							break;
							case PJSAudio.TRIANGLEWAVE:
							value = 1 - 4 * Math.abs(Math.round(step) - step);
							break;
						}
						waveLength[i] = value * amplitude;
						}
					}
					
					//calcWaveLength();
					
					var self = {
						signal: new Array(bufferSize),
						envelope: null,
						envelopedSignal: new Array(bufferSize),
						
						setAmp: function(_amplitude) {
						if (_amplitude >= 0 && _amplitude <= 1) {
							amplitude = _amplitude;
							calcWaveLength();
						} else {
							throw "Amplitude out of range (0..1).";
						}
						},
						
						setFreq: function(_frequency) {
						frequency = _frequency;
						cyclesPerSample = frequency / sampleRate;
						calcWaveLength();
						},
						
						// Add a oscillator
						add: function(_oscillator) {
						for ( var i = 0; i < bufferSize; i++ ) {
							//self.signal[i] += _oscillator.valueAt(i);
							self.signal[i] += _oscillator.signal[i];
						}
						
						return self.signal;
						},
						
						// Add a signal to the current generated osc signal
						addSignal: function(_signal) {
						for ( var i = 0; i < _signal.length; i++ ) {
							if ( i >= bufferSize ) {
							break;
							}
							self.signal[i] += _signal[i];
						}
						return self.signal;
						},
						
						// Add an envelope to the oscillator
						addEnvelope: function(_envelope) {
						self.envelope = _envelope;
						},
						
						valueAt: function(_offset) {
						return waveLength[_offset % waveLength.length];
						},
						
						generate: function() {
						/*
						var frameOffset = frameCount * bufferSize;
						var offset;
						var waveLengthSize = waveLength.length;
						
						for ( var i = 0; i < bufferSize; i++ ) {
							offset = (frameOffset + i) % waveLengthSize;
							if ( self.envelope != null ) {
							self.signal[i] = self.envelope.processSample(waveLength[offset]);
							} else {
							self.signal[i] = waveLength[offset];
							}
						}
						
						frameCount++;
						
						return self.signal;
						*/
						var value, step;
						var frameOffset = frameCount * bufferSize;
				
						for ( var i = 0; i < bufferSize; i++ ) {
							step = (frameOffset + i) * cyclesPerSample % 1;
				
							switch(waveform) {
							case PJSAudio.SINEWAVE:
								value = Math.sin(TWO_PI * step);
								break;
							case PJSAudio.SQUAREWAVE:
								value = step < 0.5 ? 1 : -1;
								break;
							case PJSAudio.SAWWAVE:
								value = 2 * (step - Math.round(step));
								break;
							case PJSAudio.TRIANGLEWAVE:
								value = 1 - 4 * Math.abs(Math.round(step) - step);
								break;
							}
							self.signal[i] = value * amplitude;
						}
				
						frameCount++;
				
						return self.signal;
						}
					};
				
					self.generate();
					
					return self;
					}; // END Oscillator
					
					this.ADSR = function(_attackLength, _decayLength, _sustainLevel, _sustainLength, _releaseLength, _sampleRate) {
					var attackLength  = _attackLength;
					var decayLength   = _decayLength;
					var sustainLevel  = _sustainLevel;
					var sustainLength = _sustainLength;
					var releaseLength = _releaseLength;
					var sampleRate    = _sampleRate;
					
					var attackSamples  = attackLength * sampleRate;
					var decaySamples   = decayLength * sampleRate;
					var sustainSamples = sustainLength * sampleRate;
					var releaseSamples = releaseLength * sampleRate;
					
					var attack = attackSamples;
					var decay = attack + decaySamples;
					var sustain = decay + sustainSamples;
					var release = sustain + releaseSamples;
					
					var samplesProcessed = 0;
					
					var self = {
						trigger: function() {
						samplesProcessed = 0;
						},
						
						process: function(_buffer) {
						for ( var i = 0; i < _buffer.length; i++ ) {
							var amplitude = 0;
							
							if ( samplesProcessed <= attack ) {
							amplitude = 0 + (1 - 0) * ((samplesProcessed - 0) / (attack - 0));
							} 
							else if ( samplesProcessed > attack && samplesProcessed <= decay ) {
							amplitude = 1 + (sustainLevel - 1) * ((samplesProcessed - attack) / (decay - attack));
							} 
							else if ( samplesProcessed > decay && samplesProcessed <= sustain ) {
							amplitude = sustainLevel;
							} 
							else if ( samplesProcessed > sustain && samplesProcessed <= release ) {
							amplitude = sustainLevel + (0 - sustainLevel) * ((samplesProcessed - sustain) / (release - sustain));
							}
							
							_buffer[i] *= amplitude;
							samplesProcessed++;
						}
						
						return _buffer;
						},
						
						processSample: function(_sample) {
						var amplitude = 0;
						
						if ( samplesProcessed <= attack ) {
							amplitude = 0 + (1 - 0) * ((samplesProcessed - 0) / (attack - 0));
						} 
						else if ( samplesProcessed > attack && samplesProcessed <= decay ) {
							amplitude = 1 + (sustainLevel - 1) * ((samplesProcessed - attack) / (decay - attack));
						} 
						else if ( samplesProcessed > decay && samplesProcessed <= sustain ) {
							amplitude = sustainLevel;
						} 
						else if ( samplesProcessed > sustain && samplesProcessed <= release ) {
							amplitude = sustainLevel + (0 - sustainLevel) * ((samplesProcessed - sustain) / (release - sustain));
						}
						
						samplesProcessed++;
						
						return _sample * amplitude;
						},
						
						isActive: function() {
						if ( samplesProcessed > release ) {
							return false;
						} else {
							return true;
						}
						}
					};
					
					return self;
					}; // END ADSR
					
					this.IIRFilter = function(_filter, _frequency, _sampleRate) {
					var filter = _filter;
					var frequency = _frequency;
					var sampleRate = _sampleRate;
					
					var a = [];
					var b = [];
					
					var calcCoeff = function() {
						var fracFreq = frequency/sampleRate;
						switch(filter) {
						case PJSAudio.LOWPASS:
						var x = Math.exp(-2*Math.PI * fracFreq);
							a = [ 1 - x ];
							b = [ x ];
						break;
						case PJSAudio.HIGHPASS:
						var x = Math.exp(-2 * Math.PI * fracFreq);
							a = [ (1+x)/2, -(1+x)/2 ];
							b = [ x ];
						break;
						}
					}
					
					calcCoeff();
				
					var memSize = (a.length >= b.length) ? a.length: b.length;
				
					var input = new Array(memSize);
					var output = new Array(memSize);
					
					for ( var i = 0; i < memSize; i++ ) {
						input[i] = 0;
						output[i] = 0;
					}
					
					var self = {
						setFreq: function(_frequency) {
						frequency = _frequency;
						calcCoeff();
						},
						
						process: function(_buffer) {
						for ( var i = 0; i < _buffer.length; i++ ) {
							var inputLength = input.length;
							for ( var c = 0; c < inputLength -1; c++ ) {
							input[c+1] = input[c];
							}
							
							input[0] = _buffer[i];
						
							var y = 0;
							for ( var j = 0; j < a.length; j++ ) {
							y += a[j] * input[j]; 
							}
							for ( var j = 0; j < b.length; j++ ) {
							y += b[j] * output[j];
							}
							
							var outputLength = output.length;
							for ( var c = 0; c < outputLength -1; c++ ) {
							output[c+1] = output[c];
							}
							
							output[0] = y;     
							_buffer[i] = y;
						}
						}
					};
					
					return self;
					}; // END IIRFilter
					
					this.LP12 = function(_cutoff, _resonance, _sampleRate) {
					var cutoff, resonance, sampleRate = _sampleRate;
					
					var w, q, r, c, vibraPos = 0, vibraSpeed = 0;
					
					var calcCoeff = function(_cutoff, _resonance) {
						w = 2.0 * Math.PI * _cutoff / sampleRate;
						q = 1.0 - w / (2.0 * (_resonance + 0.5 / (1.0 + w)) + w - 2.0);
						r = q * q;
						c = r + 1.0 - 2.0 * Math.cos(w) * q;
						
						cutoff = _cutoff;
						resonance = _resonance;
					}
				
					calcCoeff(_cutoff, _resonance);
					
					var self = {
						set: function(_cutoff, _resonance) {
						calcCoeff(_cutoff, _resonance);
						},
						
						process: function(_buffer) {
						for ( var i = 0; i < _buffer.length; i++ ) {
							vibraSpeed += (_buffer[i] - vibraPos) * c;
							vibraPos += vibraSpeed;
							vibraSpeed *= r;
							
							/*
							var temp = vibraPos;
							
							if ( temp > 1.0 ) {
							temp = 1.0;
							} else if ( temp < -1.0 ) {
							temp = -1.0;
							}
							
							_buffer[i] = temp;
							*/
							
							_buffer[i] = vibraPos;
						}
						}
					};
					
					return self;   
					}; // END LP12
				};  
				})();

</script>
				
		<!--[if lt IE 9]>
			<script type="text/javascript">alert("Your browser does not support the canvas tag.");</script>
		<![endif]-->
		
		<script type="text/javascript">
			// convenience function to get the id attribute of generated sketch html element
			function getProcessingSketchId () { return 'Music'; }
		</script>

		<div class="sketch">
				<canvas id="Music" data-processing-sources="Music.pde" 
						width="1024" height="480">
					<p>Your browser does not support the canvas tag.</p>
					<!-- Note: you can put any alternative content here. -->
				</canvas>
				<noscript>
					<p>JavaScript is required to view the contents of this page.</p>
				</noscript>
		</div>
	</body>
</html>

